# Chapter 10 예외 처리
## 핵심 개념
1. 예외 처리 기본: try, throw, catch문을 중심으로 예외 처리를 구성하는 방법
2. 스택 풀기: 스택 메모리에 불필요한 데이터가 쌓이지 않게 하려는 예외 처리 구조
3. 메모리 예외 처리: 객체가 생성 혹은 소멸하는 과정에서 발생하는 예외
## 학습 목표
1.	예외 처리의 중요성과 기본 구조를 정확하게 이해
2.	함수 실행에서 발생하는 상황에 대처하는 스택 풀기 이해
3.	객체 생성과 소멸에서 발생하는 상황에 대처하는 메모리 예외 처리 방법
--------------
<br><br>

## 1. try, throw, catch문
-  구조화된 예외 처리: 함수 호출로 변경된 것들을 한 번에 되돌릴 수 있는 방법
    - 스택을 본래 형태로 돌리는 것<br>
1. 기본 활용 방법
```
try
{
    .... //작업
    if(error 발생)
        throw errocode;
    if(error 발생)
        throw errocode;
}
catch(int nExp)
{
    ...
}
```
- goto문: statement label를 명시해준 곳으로 점프한다. 

```
tryAgain: 
    // this is a statement label
    std::cout << "Enter a non-negative number"; 
    std::cin >> x;
    if (x < 0.0)
        goto tryAgain;
    // this is the goto statement


    // c++ 에서는 적절하지 않은 명령이다.
    // 자칫 스파게티 코드를 작성할 수 있다.
    // c나 오래된 언어에서 사용함
```
- goto문과 try-catch 문의 차이
    * goto문에선 if문 내에서 예외가 발생할 경우 블록 내 실행을 완료하고 넘어감
    - try-catch에서는 중간에 예외를 발생하게 될 경우 곧바로 catch문 블록으로 넘어감
        - 예외 처리 문을 사용함으로 예외 처리 코드를 '구조적'으로 코드를 짤 수 있음
- 예외 처리를 하는 이유
    - 정상 처리문과 예외 상황을 분리함으로써 구조를 간결하게 하기 위함
    - 정상 처리하는 상황을 묶어서 관리하고, 예외 상황을 따로 빼서 관리하게 되면 실수를 줄일 수 있다.<br>
<br>
2. catch 다중화
- catch문을 여러개로 구현 가능함
- 예외를 던질 때 자료형이 다른 경우 각 상황에 맞게 catch가 가능하다.
    ```
    int nun;
    char ch;

    cin >> num >> ch ;
    try
    {
        if(num < 0>)
            throw num;
        if(ch != 'A')
            throw ch;
    }

    catch(int nExp)
    {
        cout <<"Error_int: " << nExp << endl;
    }

    catch(char ch)
    {
        cout <<"Error_char: " << ch << endl;
    }
    ```
- 더 깔끔하게 볼 수 있다.
- 예외 처리를 중첩으로 사용이 가능함
<br>
<br>
3. 예외 클래스
- 예외 처리에 사용자 정의 클래스도 catch가 가능하다.
    - 단순 자료형으로는 구체적인 메시지 또는 추가적인 정보를 담을 수 없다.
- 장점
    -  프로그램 내부에 만들어야 하는 모든 예외 정보를 한 클래스로 묶을 수 있음
    - 각종 오류를 포함한 예외 상황들을 정책적으로 관리
    - 디버깅하기가 수월하다.
<br><br>
## 2. 스택 풀기
- 호출 스택: 함수를 호출하면 매개변수, 자동 변수, 기타 추가정보가 스택 메모리에 쌓이는데 이를 디버거에서 보여준다.
- 자동 변수: 스택을 사용하는 변수
- 함수를 호출하다 에러가 발생하여 throw를 던지면 스택 메모리는 함수를 호출하기 전 상태로 돌아온다.
<br><br>
## 3. 메모리 예외 처리
- 메모리가 너무 많은 양을 할당하려고 하면 오류가 남
- 메모리를 할당해주는 함수나 연산자는 NULL을 반환하고 반환 값이 NULL인지 비교하는 방식으로 메모리 예외 처리를 시도한다.
```
catch(bad_alloc &exp)
```
- bad_alloc 을 통해 메모리 오류를 받는다. 그리고 예외 처리를 실행함
- bad_alloc 클래스는 exception 클래스의 파생 클래스이며, what()메서드를 통해 운영체제가 알려주는 메시지를 볼 수 있다.
<br><br>
<br><br>
## 연습문제
1. Stack unwinding에 대해 설명
    - 함수를 호출하고 실행하던 중에 에러가 발생하면 throw를 던지고 스택 메모리가 함수를 호출하기 전 상태로 돌아가는 것
2. bad_alloc에 대해 설명
    - 함수나 연산자가 너무많은 메모리를 할당하는 연산을 수행할 때 에러를 예외 처리를 실행한다.<br>
    이 클래스는 exception의 파생 클래스이며, 운영체제가 예외 발생 원인을 알려주는 what 메서드를 통해 원인 파악이 가능하다.
